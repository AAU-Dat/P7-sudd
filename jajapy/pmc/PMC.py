from ..base.tools import resolveRandom
from ..base.Parametric_Model import *
from numpy import ndarray, array, zeros, isnan, nan

class PMC(Parametric_Model):
	
	def __init__(self, matrix: ndarray, labeling: list,
				 parameter_values: ndarray, parameter_indexes: list,
				 parameter_str: list, name: str="unknow_PMC") -> None:
		"""
		Creates a PMC.

		Parameters
		----------
		matrix : ndarray
			Represents the transition matrix.
		labeling: list of str
			A list of N observations (with N the nb of states).
			If `labeling[s] == o` then state of ID `s` is labelled by `o`.
			Each state has exactly one label.
		parameter_values: list of float
			Contains the value for each parameter.
			`parameter_values[i]` is the instantiation for parameter `i`.
		parameter_indexes: list of ndarray
			Contains the indexes of each transition using each parameter.
			`parameter_indexes[i] = array([[0,1],[2,1]])` means that parameter `i`
			is used by the transition from state 0 to state 1 and from state 2 to state 1.
		name : str, optional
			Name of the model.
			Default is "unknow_PMC"
		"""
		super().__init__(matrix,labeling,parameter_values,parameter_indexes,parameter_str,name)
		if not self._checkProbabilities():
			msg = "At least one probability is not valid:\n"
			msg+= "1. A transition has a probability lower than 0.0 or greater than 1.0, or\n"
			msg+= "2. The probability to leave a state is different than 0.0 and 1.0."
			raise ValueError(msg)
	
	def _checkProbabilities(self,values=None) -> bool:
		if type(values) == type(None):
			values = self.parameter_values
		for s in range(self.nb_states):
			instantiated = True
			seum = 0.0
			for j in range(self.nb_states):
				prob = values[self.matrix[s,j]]
				if not isnan(prob):
					seum += prob
					if prob < 0.0 or prob > 1.0:
						return False
				else:
					instantiated = False
			if instantiated:
				if seum != 0.0 and seum != 1.0:
					return False
		return True

	def tau(self,s1: int, s2: int, obs: str) -> float:
		"""
		Returns the probability of moving from state `s1` to `s2` seeing label `obs`.
		(i.e. if `s1` is not labelled with `obs` the probability is 0.0).

		Parameters
		----------
		s1: int
			source state ID.
		s2: int
			destination state ID.
		obs: str
			seen label.
		
		Returns
		-------
		float
			probability of moving from state `s1` to `s2` seeing label `obs`.

		"""
		self._checkStateIndex(s1)
		self._checkStateIndex(s2)
		if obs != self.labeling[s1]:
			return 0.0
		return self.parameter_values[self.matrix[s1][s2]]
	
	def a(self,s1: int,s2: int) -> float:
		"""
		Returns the probability of moving from state `s1` to state `s2`.

		Parameters
		----------
		s1 : int
			ID of the source state.		
		s2 : int
			ID of the destination state.
		
		Returns
		-------
		float
			Probability of moving from state `s1` to state `s2`.
		
		Example
		-------
		>>> model.a(0,1)
		0.6
		"""
		self._checkStateIndex(s1)
		self._checkStateIndex(s2)
		return self.parameter_values[self.matrix[s1][s2]]

	def next(self,state: int) -> tuple:
		"""
		Return a state-observation pair according to the distributions described by `matrix`

		Returns
		-------
		output : (int, str)
			A state-observation pair.
			
		Example
		-------
		>>> model.next(0)
		(1,'a')
		>>> model.getLabel(0)
		'a'
		>>> model.next(0)
		(1,'a')
		>>> model.next(0)
		(2,'a')
		>>> model.a(0,1)
		0.6
		>>> model.a(0,2)
		0.4
		"""
		if not self.isInstantiated(state):
			raise ValueError("At least one of the parameter is not instantiated.")
		p = array([self.parameter_values[self.matrix[state][s2]] for s2 in range(self.nb_states)])
		c = resolveRandom(p)
		return (c, self.labeling[state])

	def instantiate(self, parameters: list, values: list) -> None:
		new_values =  super().instantiate(parameters, values)
		if self._checkProbabilities(new_values):
			self.parameter_values = new_values
		else:
			print("WARN: invalid values. Instantiation ignored.")

	def run(self, number_steps: int, current: int = -1) -> list:
		"""
		Simulates a run of length ``number_steps`` of the model and return the
		sequence of observations generated.
		
		Parameters
		----------
		number_steps: int
			length of the simulation.
		current : int, optional.
			If current it set, it starts from the state `current`.
			Otherwise it starts from an initial state.

		Returns
		-------
		output: list of str
			trace generated by the run.
		"""
		output = []
		if current == -1:
			current = resolveRandom(self.initial_state)

		while len(output) < number_steps:
			[next_state, symbol] = self.next(current)
			output.append(symbol)
			current = next_state
		
		output.append(self.labeling[current])
		return output

	def save(self, file_path:str) -> None:
		"""Save the model into a text file.

		Parameters
		----------
		file_path : str
			path of the output file.
		
		Examples
		--------
		>>> model.save("my_model.txt")
		"""
		f = open(file_path, 'w')
		f.write("PMC\n")
		super()._save(f)

	def _stateToString(self,state:int) -> str:
		res = "----STATE "+str(state)+"--"+self.labeling[state]+"----\n"
		for j in range(len(self.matrix[state])):
			if self.matrix[state][j] != 0:
				p = self.matrix[state][j]
				if self.parameter_str[p] == None:
					val = str(self.parameter_values[p])
				else:
					val = self.parameter_str[p]
					val = val.replace("$","")
					if not isnan(self.parameter_values[p]):
						val+=' (='+str(self.parameter_values[p])+')'
				res += "s"+str(state)+" -> s"+str(j)+" : "+val+'\n'
		return res

def loadPMC(file_path: str) -> PMC:
	"""
	Load a PMC saved into a text file.

	Parameters
	----------
	file_path : str
		Location of the text file.
	
	Returns
	-------
	output : PMC
		The PMC saved in `file_path`.
	
	Examples
	--------
	>>> model = loadPMC("my_model.txt")
	"""
	f = open(file_path,'r')
	l = f.readline()[:-1] 
	if l != " PMC":
		msg = "This file doesn't describe a PMC: it describes a "+l
		raise ValueError(msg)
	matrix,labeling,parameter_values,parameter_indexes,name,parameter_str = loadParametricModel(f)
	f.close()
	return PMC(matrix,labeling,parameter_values,parameter_indexes,parameter_str,name)

def createPMC(transitions: list, labeling: list, parameter_instantiation: dict,
			  initial_state, name: str ="unknown_PMC") -> PMC:
	"""
	An user-friendly way to create a PMC.

	Parameters
	----------
	transitions : [ list of tuples (int, int, float or str)]
		Each tuple represents a transition as follow: 
		(source state ID, destination state ID, probability).
		The probability can be explicitly given (then it's a float),
		or a parameter (then it's the name of the parameter).
	labeling: list of str
		A list of N observations (with N the nb of states).
		If `labeling[s] == o` then state of ID `s` is labelled by `o`.
		Each state has exactly one label.
	parameter_instantiation: dict
		An instantion for some (or all) parameters.
		`parameter_instantiation == {'p':0.5}` means that parameter `p`
		should be instantiated to 0.5. The other parameters are not
		instantiated.
	initial_state : int or list of float
		Determine which state is the initial one (then it's the id of the
		state), or what are the probability to start in each state (then it's
		a list of probabilities).
	name : str, optional
		Name of the model.
		Default is "unknow_PMC"
	
	Returns
	-------
	PMC
		the PMC describes by `transitions`, `labeling`, and `initial_state`.
	"""
	if 'init' in labeling:
		msg =  "The label 'init' cannot be used: it is reserved for initial states."
		raise SyntaxError(msg)
	
	labeling.append('init')
	
	
	states = list(set([i[0] for i in transitions]+[i[1] for i in transitions]))
	states.sort()
	nb_states = len(states)
	if type(initial_state) == int:
		transitions.append((nb_states,initial_state,1.0))
	else:
		for i,j in enumerate(initial_state):
			transitions.append((nb_states,i,j))
	
	nb_states += 1
	if nb_states > len(labeling):
		raise ValueError("All states are not labelled (the labeling list is too small).")
	elif nb_states < len(labeling):
		print("WARNING: the labeling list is bigger than the number of states")


	parameter_str = [None]
	parameter_values = [0.0]
	parameter_indexes = [[]]

	res = zeros((nb_states,nb_states),dtype='uint8')
	for t in transitions:
		if type(t[2]) == str and t[2] != '?':
			val = t[2]
			while '$' in val:
				s = val.index('$')
				e = val.index('$',s+1)
				p = val[s:e+1]
				if not p in parameter_str:
					parameter_str.append(p)
					parameter_values.append(nan)
					parameter_indexes.append([[t[0],t[1]]])
				else:
					parameter_indexes[parameter_str.index(p)].append([t[0],t[1]])
				val = val[:s] + "parameter_values["+str(parameter_str.index(p))+']'+ val[e+1:]
			temp = t[2].replace(' ','')
			if not temp in parameter_str:
				parameter_str.append(temp)
				parameter_values.append(val)
				parameter_indexes.append([])
			res[t[0],t[1]] = parameter_str.index(temp)

		else:
			parameter_str.append(None)
			parameter_indexes.append([[t[0],t[1]]])
			if type(t[2]) == float:
				parameter_values.append(t[2])
				res[t[0],t[1]] = len(parameter_values)-1
			else:
				raise SyntaxError("ERROR")
	for p in parameter_instantiation:
		if not '$'+p+'$' in parameter_str:
			print("WARNING: no parameter "+p+", instantiation ignored.")
		else:
			parameter_values[parameter_str.index('$'+p+'$')] = parameter_instantiation[p]

	val = []
	for i in parameter_values:
		if type(i) != str:
			val.append(i)
		else:
			while '[' in i:
				s = i.index('[')
				e = i.index(']')
				i = i[:s-len("parameter_values")]+ str(parameter_values[int(i[s+1:e])]) +i[e+1:]
			val.append(eval(i))
	val = array(val)
	return PMC(res, labeling, val, parameter_indexes,parameter_str,name)
